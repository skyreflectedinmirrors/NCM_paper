%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                          template.tex
%
% LaTeX template for papers conforming to the United States Sections of
% the Combustion Institue style guide.
%
% Authors:
%     Bryan W. Weber, University of Connecticut
%     Kyle E. Niemeyer, Oregon State University
%
% This work is licensed under the Creative Commons Attribution 4.0
% International License. To view a copy of this license, visit
% http://creativecommons.org/licenses/by/4.0/.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt]{ussci}

%======================================================================
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage[binary-units]{siunitx}
\usepackage{gensymb}
\usepackage{amsmath}
\sisetup{group-separator={,},
	detect-all,
	binary-units,
	list-units = single,
	range-units = single,
	range-phrase = --,
	per-mode = symbol-or-fraction,
	separate-uncertainty = true,
	multi-part-units = single,
	list-final-separator = {, and }
	%    scientific-notation = fixed
}
%======================================================================
% Add your bibliography file here, replace template.bib
\addbibresource{paper.bib}
%======================================================================
% Replace "Reaction Kinetics" in the line below by your paper topic
\newcommand\papertopic{Reaction Kinetics}
%======================================================================

\title{ Title of Paper }

\author[1]{Author Name}
\author[1]{Author Name}
\author[2]{Author Name}
\author[2,*]{Author Name}

\affil[1]{Department, Institution, Address, Country}
\affil[2]{Department, Institution, Address, Country}
\affil[*]{Corresponding author: \email{author@university.edu}}

\begin{document}
\maketitle

%====================================================================
\begin{abstract} % not to exceed 200 words
Abstract should be between 150--200 words and should state briefly the purpose
of the research, the principal results and major conclusions. An abstract is
often presented separately from the article, so it must be able to stand alone.
For this reason, References should be avoided, but if essential, then cite the
author(s) and year(s). Also, non-standard or uncommon abbreviations should be
avoided, but if essential they must be defined at their first mention in the
abstract itself.
\end{abstract}

% (Provide 2-4 keywords describing your research. Only abbreviations firmly
% established in the field may be used. These keywords will be used for
% sessioning/indexing purposes.)
\begin{keyword}
    Keyword1\sep Keyword2\sep Keyword3\sep Keyword4
\end{keyword}

%====================================================================
\section{Introduction}
%

Single Instruction, Multiple-Data (SIMD) processing, also known as vector-processing, is an important parallel computing paradigm used increasingly in scientific computing.
While central processing unit (CPU) clock speeds have increased rapidly over the past few decades---the phenomena known as Moore's Law---power consumption and head dissipation issues have caused this trend to slow.
Traditional multi-core parallelism is often used to increase CPU performance, however SIMD processors---and the related Single Instruction, Multiple Thread (SIMT) processors, e.g. graphics processing units (GPUs)---have gained recognition due to their increased floating operation throughput.
The parallel programming standard OpenCL~\cite{stone2010opencl} has further enabled adoption of vector-processing based codes in scientific computing by providing a common application program interface (API) for execution on heterogeneous systems (e.g. CPU, GPU, etc.).

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.33\linewidth]{SIMD.pdf}
	\caption{Schematic of SIMD processing.  A single processing element (e.g. a CPU core) contains a vector unit with several lanes (L0, L1, etc.).  The vector unit executes a single instruction concurrently on multiple data. Adapted from\cite{Simdfig:2016}}
	\label{F:SIMD}
\end{figure}

A SIMD instruction utilizes specialized vector processing hardware to execute the same floating point operation (e.g. multiplication, division, etc.) on multiple pieces of data concurrently (Fig.~\ref{F:SIMD}).
Nearly all modern CPUs have vector processing units capable of running SIMD instructions, typically capable of handling 2--4 concurrent double precision operations---known as the vector width.
Additionally, specialized hardware accelerators, e.g. Intel's Xeon Phi co-processor (or MIC), have been developed that have tens of cores with very wide vector widths (e.g. 4--8 double precision operations); these very wide vector widths are also expected on forthcoming Intel CPUs (the Skylake Xeon and Cannon Lake architectures).

Several recent works, e.g. \cite{CurtisGPU:2017,Sewerin20151375} have investigated SIMT-based chemical kinetic integration on GPUs, however SIMD-based chemical kinetics have been less studied in comparison.
\textcite{stone2016} implemented a linearly-implicit fourth-order stiff Rosenbrock solver in the OpenCL for various platforms including the CPU, GPU and the MIC; the Rosenbrock solver performance was compared to that of a non-stiff, fourth-order explicit Runge–Kutta–Fehlberg integrator.
Two parallelization models were investigated in OpenCL, the so called \textit{shallow}-SIMD vectorization, where each SIMD-lane solved a single chemical kinetic initial value problem (IVP), and a SIMT-vectorization where each thread solved a single IVP.
Shallow-SIMD vectorization improved the integrator performance over the OpenMP baseline by \SIrange{2.5}{2.8}{$\times$} on the CPU and \SIrange{4.7}{4.9}{$\times$} on the MIC, while the GPU performance while the GPU was \SIrange{1.4}{1.6}{$\times$} slower than the OpenMP baseline due to thread-divergence concerns.
\textcite{kroshko2013efficient} implemented a shallow-SIMD -vectorized third order Rosenbrock solver (RODAS) integrator for atmospheric chemistry on a Cell Broadband Engine---a specially designed vector processor---finding a speedup of \SI{1.89}{$\times$} over a serial version of the same code, a \SI{94}{\percent} parallel efficiency.

This work will study the performance of chemical source term evaluation of automatically generated shallow-SIMD-vectorized codes for a wide range chemical kinetic models on the CPU.
The performance will be compared to a baseline SIMT-vectorized codes to determine the effective SIMD speedup.
Finally future extensions to this work will be detailed.

\section{Methodology}
\subsection{Chemical Kinetics Equations}
The current code evaluates the following chemical source terms:

\begin{equation}
\frac{\text{d}[C_k]}{\text{d}t} = \sum_{i}^{N_R} \nu_{k,i} R_i c_i
\end{equation}
where $\frac{\text{d}[C_k]}{\text{d}t}$, $N_R$, $\nu_{k,i}$, ${R_i}$, $c_i$ are the time rate of change of the concentration of species $k$, the number of reactions in the model, the net stoichiometric coefficient of species $k$ in reaction $i$, the net rate of progress of reaction $i$, and the pressure modification of reaction $i$ respectively.
For further detail on each term, the reader is referred to our previous work~\cite{Niemeyer:2016aa}; the code is capable of evaluating all modern reaction rate types (e.g. pressure-log, chebyshev, etc.).

In addition, the temperature rate of change using the constant-pressure assumption\footnote{Note: in this context, the ``constant-pressure assumption'' refers to evaluation within a reaction sub-step in the operator splitting scheme, rather than a general constant-pressure reactive-flow simulation.} is evaluated as:
\begin{equation}
\frac{\text{d}[T]}{\text{d}t} = -\frac{\sum_{k}^{N_S} H^{\degree}_k \dot{\omega}_k}{\sum_{k}^{N_S} [C_k] c_{p_k}^{\degree}}
\end{equation}
although the code is equally capable of a evaluating the temperature rate using a constant-volume assumption, we omit this here for brevity.

\subsection{Code Generation}
Code generation is handled by the python package \texttt{loo.py}~\cite{kloeckner_loopy_2014}, which provides an interface to OpenCL allowing for unit testing and changes of program structure, e.g. data ordering, vectorization, threading patterns etc.
Additionally, \texttt{loo.py} allows for code generation for multiple languages, including (non-vectorized) C, CUDA, and Intel's ISPC compiler, which targets SIMD vectorization on the CPU and MIC.
This is a direction that may be explored in the future to compare the speedups of the various compilers.

\subsection{Data Ordering and Vectorization Patterns}
For a chemical kinetic model with species $k$ for the $j$-th thermo-chemical state to be evaluated, $[C_k]_j$ there are two choices for data-storage in memory.
In the ``C'' (row-major) format, species concentrations for $j$-th thermo-chemical state are stored sequentially in memory, i.e.: $[C_0]_0\text{,}\allowbreak C[1]_0\ldots\allowbreak [C_{N_S}]_0\text{,}\allowbreak [C_0]_1\allowbreak\ldots\allowbreak [C_{N_S}]_N$, where $N$ is the total number of thermo-chemical conditions.
Alternatively, in the ``F'' (Fortan column-major) format species concentrations a single species for all thermo-chemical states are sequential, i.e.: $[C_0]_0\text{,}\allowbreak[C_0]_1\ldots\allowbreak[C_0]_N\text{,}\allowbreak[C_1]_0\ldots\allowbreak[C_{N_S}]_N$
In Sec.~\ref{S:results} the effect of this ordering will be shown to have a large performance impact on the program runtime.

In this work, a \textit{shallow}-SIMD vectorization has been implemented, entailing each SIMD-lane evaluating the species rates for an thermo-chemical state independently.
In future efforts, a so called \textit{deep}-SIMD vectorization will be pursued allowing vector-units to cooperate to evaluate species rates for a single thermo-chemical state.
A deep-vectorization may result in SIMD-\textit{waste} in this context---similar to thread-divergence in SIMT-processing---caused by different SIMD-lanes executing different instructions (e.g. from differing for-loop bounds), however past studies demonstrate the merits of deep-SIMT vectorization on GPUs~\cite{Sewerin20151375}.

\section{Results and Discussion}
\subsection{Validation}
The reaction rates of progress, species and temperature rates in this study are validated by comparison to Cantera~\cite{Cantera}, however due to the intricacies of floating point arithmetic care must be taken when comparing results.

In obtaining the net rate of progress of reaction $i$ from the forward and reverse rates of progress, $R_{i} = R_{i}^{\prime} - R_{i}^{\prime\prime}$, a base-10 bound on the loss of precision can be found as~\cite{goldberg1991every}:
\begin{equation}
2^{-p_i} \le \left\lvert 1 - \frac{R_{i}^{\prime}}{R_{i}^{\prime\prime}} \right\rvert \le 2^{-q_i}
\label{e:bounds}
\end{equation}
with $q_i \le p_i$, while $1 - \frac{R_{i}^{\prime}}{R_{i}^{\prime\prime}}$ can be computed with accurately via use of higher-precision numbers (in this case, via use of Python's Decimal class).

Plugging the forward and reverse rate constants from Cantera into Eq.~\eqref{e:bounds} we can obtain a reasonable a-priori precision bounds $\text{P}_{\text{min},i} = 2^{-p_i}$, $\text{P}_{\text{max},i} = 2^{-q_i}$.
Finally, when determining the error in the net rates of progress between this code and Cantera, the range of percent error attributable to precision loss, $\text{P}_{\text{err},i}$ can be found as:
\begin{equation}
\frac{\left\lvert\ R_{i,\text{CT}} - R_{i}\right\rvert}{\text{P}_{\text{min},i}} \le
\frac{\text{P}_{\text{err},i}}{100} \le \frac{\left\lvert R_{i,\text{CT}} - R_{i} \right\rvert}{\text{P}_{\text{max},i}}
\label{e:rel_bound}
\end{equation}
where the \text{CT} subscript indicates values from Cantera.
Note that the differences in Eq.~\eqref{e:rel_bound} are not subject to the same scrutiny as when computing the net rate of progress, namely because if they were small enough to merit this analysis the error would be minimal anyways.

With this we can properly validate the code against Cantera, as seen in Table~\todo[inline]{this}

\subsection{Results}
\label{S:results}


\label{results}

\section{Conclusions}
%

\section{Acknowledgements}
This research was funded by \ldots

\noindent\textbf{Page Limits:} The total length of the paper including references should be limited to 6 pages.

\printbibliography[heading=bibintoc]

\end{document}
